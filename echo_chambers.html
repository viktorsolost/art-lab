<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Chambers // A Generative Study</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0a0a0a;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #444;
            pointer-events: none;
            font-size: 12px;
            z-index: 10;
        }
        #title {
            color: #888;
            margin-bottom: 5px;
        }
        .instruction {
            opacity: 0;
            animation: fadeIn 2s forwards 1s;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="title">ECHO CHAMBERS // GEN 001</div>
        <div class="instruction">Move cursor to disrupt fields. Click to inject energy.</div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let agents = [];
        let grid = [];
        const GRID_SIZE = 20; // Size of flow field cells
        let cols, rows;
        let time = 0;
        
        // Configuration
        const AGENT_COUNT = 300;
        const AGENT_SPEED = 2;
        const DECAY = 0.96; // Trail fade speed
        const COLOR_PALETTE = [
            '#FF3F3F', // Bright Red
            '#FF9D00', // Orange
            '#F7FF00', // Yellow
            '#00FF8C', // Cyan-Green
            '#00Eaff'  // Cyan
        ];

        class Agent {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.history = [];
                this.maxHistory = 15 + Math.random() * 20;
                this.color = COLOR_PALETTE[Math.floor(Math.random() * COLOR_PALETTE.length)];
                this.size = Math.random() * 2 + 1;
                this.energy = 1.0;
            }

            update(flowField, mouseX, mouseY, mouseDown) {
                // Determine grid cell
                const col = Math.floor(this.x / GRID_SIZE);
                const row = Math.floor(this.y / GRID_SIZE);
                
                if (col >= 0 && col < cols && row >= 0 && row < rows) {
                    const angle = flowField[col + row * cols];
                    // Steer towards flow angle
                    this.vx += Math.cos(angle) * 0.1;
                    this.vy += Math.sin(angle) * 0.1;
                }

                // Mouse interaction (repulsion/attraction)
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const interactionRadius = mouseDown ? 300 : 150;
                
                if (dist < interactionRadius) {
                    const force = (interactionRadius - dist) / interactionRadius;
                    const angleToMouse = Math.atan2(dy, dx);
                    
                    if (mouseDown) {
                        // Attraction/Orbit when clicked
                        this.vx -= Math.cos(angleToMouse) * force * 2;
                        this.vy -= Math.sin(angleToMouse) * force * 2;
                        this.energy = Math.min(this.energy + 0.05, 2.0);
                    } else {
                        // Repulsion/Disruption
                        this.vx += Math.cos(angleToMouse) * force * 0.5;
                        this.vy += Math.sin(angleToMouse) * force * 0.5;
                        this.energy = Math.min(this.energy + 0.02, 1.5);
                    }
                }

                // Physics limits
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                const maxSpeed = AGENT_SPEED * (1 + this.energy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Wrap around
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;

                // Decay energy
                this.energy *= 0.99;

                // History for trails
                this.history.push({x: this.x, y: this.y});
                if (this.history.length > this.maxHistory * this.energy) {
                    this.history.shift();
                }
            }

            draw(ctx) {
                if (this.history.length < 2) return;

                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);
                for (let i = 1; i < this.history.length; i++) {
                    // Quadratic bezier for smoothness
                    // simple line for performance in this specific style
                    ctx.lineTo(this.history[i].x, this.history[i].y);
                }
                
                ctx.strokeStyle = this.color;
                // Opacity based on energy
                ctx.globalAlpha = 0.3 * this.energy;
                ctx.lineWidth = this.size * this.energy;
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }
        }

        // Noise function (Simplex-like simple implementation for flow field)
        // Using a simple pseudo-random gradient noise
        function noise(x, y, z) {
            const p = new Float32Array(512);
            const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
            for (let i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i];

            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            const Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            
            const u = fade(x);
            const v = fade(y);
            const w = fade(z);
            
            const A = p[X]+Y, AA = p[A]+Z, AB = p[A+1]+Z, 
                  B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;

            return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),  
                                     grad(p[BA], x-1, y, z)), 
                             lerp(u, grad(p[AB], x, y-1, z),  
                                     grad(p[BB], x-1, y-1, z))),
                     lerp(v, lerp(u, grad(p[AA+1], x, y, z-1),  
                                     grad(p[BA+1], x-1, y, z-1)), 
                             lerp(u, grad(p[AB+1], x, y-1, z-1),  
                                     grad(p[BB+1], x-1, y-1, z-1))));
        }
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function grad(hash, x, y, z) {
            const h = hash & 15;
            const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        }

        let mouseX = -1000, mouseY = -1000;
        let mouseDown = false;

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            cols = Math.ceil(width / GRID_SIZE);
            rows = Math.ceil(height / GRID_SIZE);
            
            // Initialize agents
            agents = [];
            for (let i = 0; i < AGENT_COUNT; i++) {
                agents.push(new Agent());
            }

            // Events
            window.addEventListener('resize', () => {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                cols = Math.ceil(width / GRID_SIZE);
                rows = Math.ceil(height / GRID_SIZE);
            });
            
            canvas.addEventListener('mousemove', e => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mousedown', () => mouseDown = true);
            canvas.addEventListener('mouseup', () => mouseDown = false);
            
            // Touch support
            canvas.addEventListener('touchstart', e => {
                mouseDown = true;
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                e.preventDefault();
            });
            canvas.addEventListener('touchmove', e => {
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                e.preventDefault();
            });
            canvas.addEventListener('touchend', () => mouseDown = false);
        }

        function updateFlowField() {
            // Update noise time
            time += 0.003;
            
            flowField = new Float32Array(cols * rows);
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    // 3D noise (x, y, time) for animated flow
                    const angle = noise(x * 0.05, y * 0.05, time) * Math.PI * 4;
                    flowField[x + y * cols] = angle;
                }
            }
            return flowField;
        }

        function animate() {
            // Semi-transparent clear for trail effect
            ctx.fillStyle = `rgba(10, 10, 10, ${1 - DECAY})`;
            ctx.fillRect(0, 0, width, height);
            
            // Update flow field
            const flowField = updateFlowField();
            
            // Update and draw agents
            agents.forEach(agent => {
                agent.update(flowField, mouseX, mouseY, mouseDown);
                agent.draw(ctx);
            });
            
            requestAnimationFrame(animate);
        }

        init();
        animate();
    </script>
</body>
</html>
